# -*- coding: utf-8 -*-
"""AgentBasedModel_tsm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TruTl-Gaa6RCokwNEIUUT-_4mXZU5x-Y

Agent-based model sample

**(tsm = traders, stakers, and moderators)**

This is a multi-period agent-based model and simulation of tokenomics including task verification mechanism, staking and trading mechanisms.

This document is organized as follows:

* Initialize Environment

* ABM Simulation - TSM:

1.  Initial Parameters (User input)
2.  Functions
3.  Simulation of Day 1 (only buyers and ITE)
4.  Simulation of Day 2 to end
5.  Results
"""

## UPDATES:
## Line 27 in Initial parameters ----> Added task cost in dollars
## Line 36 in Functions-Moderation process/evaluate() ----> Implemented new task cost fixed in USD Ct=task_usd/p(t-1)

"""# Initialize Environment"""

# Commented out IPython magic to ensure Python compatibility.
# %reset
# Setup
import time
start_time = time.time()
import random
import math
from IPython.display import display
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
import matplotlib.pyplot as plt
from matplotlib import rc
rc('mathtext', default='regular')
import scipy.stats as ss
from scipy.stats import norm
from scipy.stats import skewnorm
from random import choices
import seaborn as sns
from types import CodeType
from scipy.stats import halfnorm
from scipy.stats import chi
from scipy.stats import truncnorm
# Uncomment following liens in case you want to save plots in your local drive:
#from google.colab import files
#from google.colab import drive
#drive.mount('/drive', force_remount=True)

"""### Monthly Remaining Initial Token Endowment (ITE)"""

#############################################################################
## (a) Remaining ITE with lockup period > 0
## (b) Remaining ITE with lockup period > 12
#############################################################################
#rm_TOK = [123.3, 17.3, 17.3, 17.3, 17.3, 17.3, 24.3, 20.1, 20.1, 20.1, 20.1,
#          20.1, 24.5, 16.2, 16.2, 16.2, 16.2, 16.2, 16.2, 16.2, 16.2, 16.2,
#          16.2, 16.2, 16.2, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0,
#          12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 12.0, 9.3,
#          9.3, 9.3, 9.3, 9.3] # with reserve
# Monthly release TOK without including reserve:
rm_TOK = [119.5, 13.490, 13.490, 13.490, 13.490, 13.490, 20.490, 16.226, 16.226,
          16.226, 16.226, 16.226, 20.670, 12.337, 12.337, 12.337, 12.337, 12.337,
          12.337, 12.337, 12.337, 12.337, 12.337, 12.337, 12.337, 8.170, 8.170,
          8.170, 8.170, 8.170, 8.170, 8.170, 8.170, 8.170, 8.170, 8.170, 8.170,
          8.170, 8.170, 8.170, 8.170, 8.170, 8.170, 5.434, 5.434, 5.434, 5.434,
          5.434, 0.990]        # without reserve
monthly_released_TOK = [item * 1e6 for item in rm_TOK]
mm = monthly_released_TOK
#------------------------
# (a) Lockup period > 0:
#------------------------
tot_ite = 1e9
residual = np.empty(len(mm))
for i, vals in enumerate(mm):
  residual[i] = tot_ite - vals
  tot_ite = residual[i]
#-------------------------
# (b) Lockup period > 12:
#-------------------------
r13 = residual[12:49]
res_13 = np.empty(len(mm))
res_13[0:37] = r13
res_13[37:49] = np.nan
#--------------------------------------------------
# PLOT:
month = np.arange(0,49)#
fig = plt.figure(figsize=(8,6), dpi=100)
x = month
y = residual
y2 = res_13
plt.plot(x,y, linestyle="",marker="o")
plt.plot(x, y2,linestyle="",marker="o")
plt.xlabel('Months')
plt.ylabel('Remaining TOK tokens')
lab= ["Lockup period > 0","Lockup period > 12"]
plt.legend(lab)
plt.show()

#############################################################################
# DATAFRAME with values in previous plot
#remaining_OGY_DF = pd.DataFrame(month, columns=['Month'])
#remaining_OGY_DF['OGY remaining (lockup>0)'] = residual # lockup > 0
#remaining_OGY_DF['OGY remaining (lockup>12)'] = res_13 # lockup > 0
#display(round(remaining_OGY_DF[0:49], 2))

"""# ABM Simulation - TSM

1.    Initial Parameters
2.    Functions
3.    Day 1
4.    Day 2 to end
5.    Results

## 1. Initital Parameters
"""

#############################################################################
## INITIAL PARAMETERS FOR STAKING AND TRADING SIMULATION
##    UNITS = CENTS
#############################################################################
#--------------------------------
#@title Specify the parameters for the staking and trading processes:
#--------------------------------
#-----------------------------
## Inititalize arrays:
#-----------------------------
L_buyers = []
L_sellers = []
volume = []
number_buyers = []
number_sellers = []
desp_sellers = []
price = []
stk_r = []
total_staked = []
n_stakers = []
e_stk = []
stakers_stake = []
liquid = []
senior_reward = []
msenior_rew = []
mjunior_rew = []
liquid_in_period = [] # only from moderation
# Endowment:
endowment = monthly_released_TOK
# Daily release TOK from Reserve for the fist 4 years
daily_reserve = 125770 #@param {type:"number"}
# Initial price in cents:
initial_price = 3#@param {type:"number"}
price.append(initial_price)
# Mean for number of buyers and sellers:
nb_mean = 1000#@param {type:"number"}
# Mean and sd of USDT cents for buyers:
QU_mean = 5.#@param {type:"number"}
QU_sd = 0.5#@param {type:"number"}
# Total number of periods:
epoch = 49#@param {type:"number"}
period = np.arange(2,epoch+1)
# Parameters for alpha buy/sell:
#alpha_mean = 0.#@param {type:"number"}
#alpha_sd = 1.#@param {type:"number"}
alpha_loc = -3#@param {type:"number"}
alpha_scale = 2#@param {type:"number"}
# Parameters for beta locking:
bl_df = 2#@param {type:"number"}
bl_loc = 0#@param {type:"number"}
bl_scale = 0.1#@param {type:"number"}
# Parameters for beta unlocking:
bu_df = 2#@param {type:"number"}
bu_loc = 0#@param {type:"number"}
bu_scale = 0.6#@param {type:"number"}
# Parameters for dissolve delay:
#TL_min = 12#@param {type:"number"}
#TL_max = 15#@param {type:"number"}
TL_loc = 12#@param {type:"number"}
TL_scale = 12#@param {type:"number"}
# Parameters for critical time:
TC_df = 2#@param {type:"number"}
TC_loc = 1#@param {type:"number"}
TC_scale = 6#@param {type:"number"}
#Period 0:
#initial_staking_reward = 0#@param {type:"number"}
#initial_staked = 0#@param {type:"number"}
#initial_n_stakers = 0#@param {type:"number"}
#n_stakers.append(initial_n_stakers)
#stk_r.append(initial_staking_reward)
#total_staked.append(initial_staked)
#############################################################################

#############################################################################
## INITIAL PARAMETERS FOR SIMULATION OF MODERATION PROCESS
#############################################################################
#--------------------------------
#@title Specify the parameters for the moderation process:
#--------------------------------
#-----------------------------
## Inititalize arrays:
#-----------------------------
number_tasks = []
mode_cost = []
treasury = []
burned =[]
seniors_staked = []
mode_liquid = []
rewards = []
#-----------------------------
# Number of moderators in pool:
user_pool_number = 600 #@param {type:"number"}
# Percentage of senior moderators in pool:
senior_percentage = 0.5 #@param {type:"number"}
# Number of cases:
Nt_min = 10 #@param {type:"number"}
Nt_max = 30 #@param {type:"number"}
Nt_steps = 1 #@param {type:"number"}
# Cost per task in dollars (USD):
task_usd_dollars =  1#@param {type:"number"}
task_cents = task_usd_dollars*100
# Cost per moderator (TOK):
Cs = 5 #@param {type:"number"}
multiplier = 100000 #@param {type:"number"}
# Exponent for seniors stake:
eta = 2 #@param {type:"number"}
# Fraction  to treasury, moderation, and burned:
rt = 0.2 #@param {type:"number"}
rm = 0.5 #@param {type:"number"}
rb = 0.3 #@param {type:"number"}
# Alpha staking(seniors) and Alpha lock (juniors):
aS = 2 #@param {type:"number"}
aL = 50 #@param {type:"number"}
#############################################################################

"""## 2. Functions

### Functions - Trading

#### Alpha
"""

#######################################################
## NORMAL DISTRIBUTION   (integers only)
#######################################################
#def int_norm(min, max, sd, den):
def int_norm(mean, sd):
  #data = np.random.normal(0, sd*10, size = 1000)
  data = np.random.normal(mean, sd*10)
  #data = data.round().astype(int)/10
  data = np.floor(data)/10
  #w = 0.25
  #bins = math.ceil((data.max() - data.min())/w)
  #plt.hist(data, bins)
  #plt.show()
  return data#, plt
#######################################################

"""#### USDT Distribution
Normal distribution
"""

#########################################
## USDT or TOK
#########################################
def money_normal(mean, sigma):
    x = np.random.normal(mean, sigma)
    return x
#########################################
#x = money_normal(1,0.1)
#w = 0.007
#bins = math.ceil((x.max() - x.min())/w)
#plt.hist(5e6*x, bins)
#plt.show()

"""#### Number of agents
Normal distribution
"""

#######################################################
## NORMAL DISTRIBUTION   (integers only)
#######################################################
#[nb, plt] = nagents(1000,100)
x = np.random.normal(1,0.1, size=1000)
#x = money_normal(1,0.1)
w = 0.02
bins = math.ceil((x.max() - x.min())/w)
fig = plt.figure(figsize=(8,6), dpi=100)
plt.hist(1e3*x, bins)
ax = fig.add_subplot()
fig.subplots_adjust(top=0.9)
# Set titles for the figure and the subplot respectively
fig.suptitle('Number of Buyers', fontsize=14, fontweight='bold')
ax.set_title(r'Normal distribution, $N^b \in ND(\mu=1000, \sigma=100)$')
plt.xlabel('Number of Buyers')
plt.ylabel('Frecuency')
plt.show()
#######################################################

"""#### Critical Sellers"""

##################################################
## FIND DESPERATE SELLERS
##################################################
def desperate_sellers(sellers_DF, idx_period):
  sum_next = 0
  for i, vals in enumerate(sellers_DF['critical_time']):
    #ivals = int(vals)
    #print('Integer of critical time: ', vals)
    if vals <=1.0:
      sum_next+=1
    if vals <= 0:
      print('I found a desperate seller')
      sellers_DF.loc[i, 'status'] = 'desperate'
  sum_desp = sellers_DF.loc[sellers_DF['status']=='desperate', 'Q_TOK'].sum()
  print(f"number of sellers potentially selling next period: {sum_next}")
  return sellers_DF, sum_desp
##################################################
#[desperate, sum_d] = desperate_sellers(sellers_DF)

n = random.uniform(0,1)
print(n)

"""#### Generate Buyers"""

#############################################################################
## Generate BUYERS
## TYPE(generate_agents)(int, array, int, float, float, float, float)
#############################################################################
def generate_buyers(nb_mean, price, period_index, QU_mean, QU_sd, alpha_loc,
                    alpha_scale, TC_df,TC_loc, TC_scale, bl_df, bl_loc,bl_scale,
                    bu_dff, bu_locc, bu_scalee, TL_loc, TL_scale):
  mean = nb_mean/1e3
  nb = np.random.normal(mean,0.1)*1e3
  N = np.arange(1,nb+1).astype(int) # BUYERS array
  Q_USDT = np.empty(len(N))
  alpha_b = np.empty(len(N))
  alpha_s = np.empty(len(N))
  buy_states = []
  TC = np.empty(len(N))
  alock = np.empty(len(N))
  bunlock = np.empty(len(N))
  lockt = np.empty(len(N))
  for j in N-1:
    Q_USDT[j] = money_normal(QU_mean,QU_sd)*1e5
    #####################################################
    #alpha_b[j] = int_norm(0., 1.) # mean, sd
    #alpha_s[j] = int_norm(0., 1.)
    #alock[j] = round(random.uniform(0., 0.2),2)
    #bunlock[j] = random.uniform(0., 1.)
    #TC[j] = random.randint(1, 24)
    #lockt[j] = random.randint(12, 48)
    #####################################################
    alpha_b[j] = halfnorm.rvs(alpha_loc, alpha_scale)
    alpha_s[j] = -halfnorm.rvs(alpha_loc, alpha_scale)
    alock[j] = chi.rvs(bl_df, bl_loc, bl_scale)
    bunlock[j] = chi.rvs(bu_df,bu_loc,bu_scale)
    TC[j] = int(chi.rvs(TC_df, TC_loc, TC_scale))
    lockt[j] = int(halfnorm.rvs(TL_loc, TL_scale))
    #####################################################
    bid_price = price[period_index] + alpha_b[j]
    ask_price = np.nan
    Q_TOK = Q_USDT[j]/bid_price
    #alock[j] = round(random.randint(a_min, a_max*100)/100, 2)

    buy_states.append([alpha_b[j], bid_price, Q_USDT[j], alpha_s[j],
                       ask_price, Q_TOK, TC[j], alock[j], bunlock[j], int(lockt[j])])
  df_buy = pd.DataFrame(buy_states, columns=["alpha_buy","bid_price",
                                             "Q_USDT", "alpha_sell",
                                             "ask_price", "QB_TOK",
                                             "critical_time", "beta_lock",
                                             "beta_unlock", "dissolve_delay"])
  A_DF = df_buy.sort_values(by=["bid_price"], ascending=False) # highest to lowest
  A_DF['status']='trader'
  A_DF = A_DF[A_DF.bid_price > 0]
  A_DF = A_DF.reset_index(drop=True)
  return A_DF
#############################################################################
#display(buyers)

"""#### Generate potential sellers (buyers in previous period)"""

#############################################################################
## Generate SELLERS
## TYPE(generate_agents)(int, array, int, float, float, float, float)
#############################################################################
def generate_sellers(idx, price, period_index, buyers_DF):
  sell_states = []
  sell_USDT = buyers_DF.loc[0:idx, 'Q_USDT']
  TOK_sellers = sell_USDT/price[period_index]
  alpha = buyers_DF.loc[0:idx, 'alpha_sell']
  time_c = buyers_DF.loc[0:idx, 'critical_time']
  al = buyers_DF.loc[0:idx, 'beta_lock']
  bl = buyers_DF.loc[0:idx, 'beta_unlock']
  dd = buyers_DF.loc[0:idx, 'dissolve_delay']
  QU = 0.0
  QO = 1.0
  ns = len(sell_USDT)
  N = np.arange(1, ns+1)
  for i in N-1:
    sell_price = price[period_index] + alpha[i]
    sell_states.append([alpha[i], sell_price])

  sellers_DF = pd.DataFrame(sell_states, columns=['alpha_sell', 'ask_price'])
  sellers_DF['Q_TOK'] = TOK_sellers
  sellers_DF['critical_time']= time_c
  sellers_DF['beta_lock'] = al
  sellers_DF['beta_unlock'] = bl
  sellers_DF['dissolve_delay'] = dd
  sellers_DF['Q_s']=0
  sellers_DF['Q_r']=0
  sellers_DF['sum_Q_r']=0
  sellers_DF['status']='trader'
  sellers_DF = sellers_DF.sort_values(by=["ask_price"]) # lowest to highest
  sellers_DF = sellers_DF[sellers_DF.ask_price > 0]
  sellers_DF = sellers_DF.reset_index(drop=True)
  return sellers_DF
#############################################################################

"""#### Cumulative Supply&Demand"""

##################################################
## CUMULATIVE SUPPLY AND DEMAND
##################################################
def cumulative_sd(nb, ns, buyers_DF, sellers_DF, sum_desp, endowment, moderation):
  #[desp, sum_desp] = desperate_sellers(sellers_DF)
  # DEMAND:
  cumulative_usdt = np.cumsum(buyers_DF['Q_USDT'])
  price = buyers_DF['bid_price']
  buyers_DF['cumulative_demand'] = cumulative_usdt/price
  # SUPPLY:
  sellers_supply = np.cumsum(sellers_DF.loc[sellers_DF['status']=='trader', 'Q_TOK'])
  if len(sellers_supply)==0:
    sellers_DF['cumulative_supply'] = endowment - moderation
  else:
    sellers_DF['cumulative_supply'] = endowment + sum_desp + sellers_supply - moderation
  #sellers_DF['cumulative_supply'] = endowment + sum_desp + sellers_supply
  sellers_DF.reset_index(drop=True)
  return buyers_DF, sellers_DF, sellers_supply
###############################################################################
#[dem, sup] = cumulative_sd(nb, ns, buyers_DF, sellers_DF, endowment, 0)
#[buyers_DF, sellers_DF] = cumulative_sd(nb, 409, one_buyers, one_sellers, endowment)

"""#### Update sellers"""

import copy
################################################################################
## UPDATE SELLERS
################################################################################
def update_sellers(price,j,buyer_idx, seller_idx, buyers_DF,sellers_DF, rem_usdt):
  #buyers_DF.loc[buyer_idx, 'Q_USDT'] = rem_usdt
  sell_USDT = buyers_DF.loc[0:buyer_idx, 'Q_USDT']
  TOK_sellers = sell_USDT/price[j]
  alsell = buyers_DF.loc[0:buyer_idx, 'alpha_sell']
  critime = buyers_DF.loc[0:buyer_idx, 'critical_time']
  al = buyers_DF.loc[0:buyer_idx, 'beta_lock']
  bl = buyers_DF.loc[0:buyer_idx, 'beta_unlock']
  tl = buyers_DF.loc[0:buyer_idx, 'dissolve_delay']
  ns = len(alsell)
  N = np.arange(1, ns+1)
  s_price = np.empty(len(N))

  for i, vals in enumerate(alsell):
    s_price[i] = price[j] + vals

  new_sellers = pd.DataFrame(s_price, columns=["ask_price"])

  new_sellers['alpha_sell'] = alsell
  new_sellers['Q_TOK'] = TOK_sellers
  new_sellers['critical_time'] = critime - 1
  new_sellers['beta_lock'] = al
  new_sellers['beta_unlock'] = bl
  new_sellers['dissolve_delay'] = tl
  new_sellers['Q_s']=0
  new_sellers['Q_r']=0
  new_sellers['sum_Q_r']=0
  new_sellers['status']='trader'
  new_sellers = new_sellers.iloc[:, [1,0,2,3,4,5,6,7,8,9,10]]
  #print(new_sellers)
  #--------------------------------------------
  # Update info for sellers that didn't sell:
  #--------------------------------------------
  #sellers_DF = sellers_DF.drop[sellers_DF['status']== 'desperate']
  sellers_DF.drop(sellers_DF[sellers_DF['status'] == 'desperate'].index, inplace = True)
  end = len(sellers_DF)
  old_alpha = sellers_DF.loc[seller_idx:end-1,'alpha_sell']
  old_sellers = pd.DataFrame(old_alpha, columns=["alpha_sell"])

  old_TOK = sellers_DF.loc[seller_idx:end-1,'Q_TOK']
  old_critime = sellers_DF.loc[seller_idx:end-1,'critical_time']
  old_alock = sellers_DF.loc[seller_idx:end-1,'beta_lock']
  old_bunlock = sellers_DF.loc[seller_idx:end-1,'beta_unlock']
  old_tl = sellers_DF.loc[seller_idx:end-1,'dissolve_delay']
  old_qs = sellers_DF.loc[seller_idx:end-1,'Q_s']
  old_qr = sellers_DF.loc[seller_idx:end-1,'Q_r']
  old_sqr = sellers_DF.loc[seller_idx:end-1,'sum_Q_r']
  old_stat = sellers_DF.loc[seller_idx:end-1,'status']

  nos = len(old_alpha)
  M = np.arange(1, nos+1)
  sell_price = np.empty(len(M))
  for i, vals in enumerate(old_alpha):
    sell_price[i] = price[j] + vals

  old_sellers['ask_price'] = sell_price
  old_sellers['Q_TOK'] = old_TOK
  #print('Old critical time:', old_critime)
  old_sellers['critical_time'] = copy.deepcopy(old_critime - 1)
  #print('New critical time, ', old_sellers['critical_time'])
  old_sellers['beta_lock'] = old_alock
  old_sellers['beta_unlock'] = old_bunlock
  old_sellers['dissolve_delay'] = old_tl
  old_sellers['Q_s'] = old_qs
  old_sellers['Q_r'] = old_qr
  old_sellers['sum_Q_r'] = old_sqr
  old_sellers['status'] = old_stat
  #display(old_sellers)
  #------------------------------
  # Concatenate sellers' frames:
  #------------------------------
  s_frames = [new_sellers, old_sellers]
  next_sellers = pd.concat(s_frames)
  #next_sellers.dropna(subset = ["Q_TOK"], inplace=True)
  next_sellers = new_sellers.sort_values(by=["ask_price"]) # lowest to highest
  next_sellers = next_sellers.reset_index()
  return next_sellers
##################################################

#[ns, ot] = update_sellers(price,j,buyer_idx, seller_idx, buyers_DF,sellers_DF, rem_usdt)

"""#### Equilibrium price"""

#############################################################################
## Determine EQUILIBRIUM PRICE
## TYPE(price)(dataframe, dataframe)
#############################################################################
def eq_price(buyers_DF, sellers_DF):
  buy = pd.DataFrame()
  sell = pd.DataFrame()
  buy['price'] = buyers_DF['bid_price']
  buy['qty_buyers'] = buyers_DF['QB_TOK']
  buy['cum_qty_buyers'] = buyers_DF['cumulative_demand']
  sell['price'] = sellers_DF['ask_price']
  sell['qty_sellers'] = sellers_DF['Q_TOK']
  sell['cum_qty_sellers'] = sellers_DF['cumulative_supply']
  market=pd.merge(buy.sort_values("price", ascending=True).reset_index(drop=True),
                sell, on="price", how ="outer", suffixes=
                ("_buyers", "_sellers")).sort_values("price").fillna(method="ffill").reset_index(drop=True)
  equilibrium_idx = abs(np.sign(market.cum_qty_buyers - market.cum_qty_sellers).diff()).argmax()
  #equilibrium_price = market.loc[equilibrium_idx-1:equilibrium_idx+1,"price"].mean()
  equilibrium_price = market.loc[equilibrium_idx,"price"]
  eq_supply = market.loc[equilibrium_idx, 'cum_qty_sellers']
  eq_demand = market.loc[equilibrium_idx, 'cum_qty_buyers']
  split_demand = market.loc[equilibrium_idx-1, 'cum_qty_buyers']
  bidx = buyers_DF.index[buyers_DF['cumulative_demand'] == split_demand].tolist()
  sidx = sellers_DF.index[sellers_DF['cumulative_supply'] == eq_supply].tolist()
  buyer_idx = bidx[0]
  seller_idx = sidx[0]
  return equilibrium_price, buyer_idx, seller_idx, eq_supply, eq_demand
#############################################################################

"""### Functions -  All plots"""

#-----------------------------------------------------------------------------
# ALPHA HISTOGRAM
#-----------------------------------------------------------------------------
def plot_alpha(A_DF, i):
  # ALPHA BUY
  if A_DF['ask_price'].hasnans:
    fig = plt.figure(figsize=(8,6), dpi=100)
    plt.hist(A_DF['alpha_buy'], 30)
    ax = fig.add_subplot()
    fig.subplots_adjust(top=0.9)
    # Set titles for the figure and the subplot respectively
    fig.suptitle('Alpha Buy, period %s'%i, fontsize=14, fontweight='bold')
    ax.set_title(r'Half-normal distribution, $\alpha^b \in H-ND(\mu_0=-3, \sigma=2)$')
    plt.xlabel('Alpha Buy')
    plt.ylabel('Frecuency')
  # ALPHA SELL
  else:
    fig = plt.figure(figsize=(8,6), dpi=100)
    plt.hist(A_DF['alpha_sell'], 30)
    ax = fig.add_subplot()
    fig.subplots_adjust(top=0.9)
    # Set titles for the figure and the subplot respectively
    fig.suptitle('Alpha Sell, period %s'%i, fontsize=14, fontweight='bold')
    ax.set_title(r'Negative Half-normal distribution, $\alpha^s \in -H-ND(\mu_0=-3, \sigma=2)$')
    plt.xlabel('Alpha Sell')
    plt.ylabel('Frecuency')
  return plt
#-----------------------------------------------------------------------------
#plot_alpha(buyers_DF)
#plot_alpha(sellers_DF)

#-----------------------------------------------------------------------------
# USDT HISTOGRAM
#-----------------------------------------------------------------------------
def plot_usdt(A_DF, i):
    fig = plt.figure(figsize=(8,6), dpi=100)
    plt.hist(A_DF['Q_USDT'], 30)
    ax = fig.add_subplot()
    fig.subplots_adjust(top=0.9)
    # Set titles for the figure and the subplot respectively
    fig.suptitle('Amount of USDT', fontsize=14, fontweight='bold')
    ax.set_title(r'Normal distribution, $Q^U \in  ND(\mu=5e6, \sigma=5e5)$ cents')
    plt.xlabel('Quantity (USDT cents)')
    plt.ylabel('Frecuency')
    return plt
#-----------------------------------------------------------------------------
#plot_usdt(buyers_DF)

#-----------------------------------------------------------------------------
# TOK HISTOGRAM
#-----------------------------------------------------------------------------
def plot_TOK(A_DF, i):
    fig = plt.figure(figsize=(8,6), dpi=100)
    plt.hist(A_DF['Q_TOK'], 30)
    plt.xlabel('Quantity (TOK)')
    plt.ylabel('Frecuency')
    #return plt

#-----------------------------------------------------------------------------
# PRICE HISTOGRAM
#-----------------------------------------------------------------------------
def price_distribution(A_DF, i, price):
  # BUYERS PRICE
  if A_DF['ask_price'].hasnans:
    fig = plt.figure(figsize=(8,6), dpi=100)
    ax = fig.add_subplot()
    fig.subplots_adjust(top=0.9)
    fig.suptitle('Bid prices, period %s' %i, fontsize=14, fontweight='bold')
    ax.set_title(r'$p^b=P_{t-1} + \alpha^b = %s + \alpha^b$' %round(price[i-1],2))
    plt.hist(A_DF['bid_price'], 30)
    plt.xlabel('Bid price')
    plt.ylabel('Frecuency')
    plt.show()
  else:
  # SELLERS PRICE
    fig = plt.figure(figsize=(8,6), dpi=100)
    ax = fig.add_subplot()
    fig.subplots_adjust(top=0.9)
    fig.suptitle('Ask prices, period %s' %i, fontsize=14, fontweight='bold')
    ax.set_title(r'$p^s=P_{t-1} + \alpha^s = %s + \alpha^s$' %round(price[i-1],2))
    plt.hist(A_DF['ask_price'], 30)
    plt.xlabel('Ask price')
    plt.ylabel('Frecuency')
    plt.show()
  return plt

#-----------------------------------------------------------------------------
# CRITICAL TIME HISTOGRAM
#-----------------------------------------------------------------------------
def critical_time(A_DF,i):
  fig = plt.figure(figsize=(8,6), dpi=100)
  ax = fig.add_subplot()
  fig.subplots_adjust(top=0.9)
  fig.suptitle('Critical Time', fontsize=14, fontweight='bold')
  ax.set_title(r'Truncated Chi distribution, $T^C \in$  Chi$(k=2, loc=1, \sigma=6)$ months')
  plt.hist(A_DF['critical_time'], 30)
  plt.xlabel('Months')
  plt.ylabel('Frecuency')
  plt.show()
  return plt

#-----------------------------------------------------------------------------
# BETA LOCK HISTOGRAM
#-----------------------------------------------------------------------------
def alo(A_DF,i):
  fig = plt.figure(figsize=(8,6), dpi=100)
  ax = fig.add_subplot()
  fig.subplots_adjust(top=0.9)
  fig.suptitle('Beta lock, period %s' %i, fontsize=14, fontweight='bold')
  ax.set_title(r'Chi distribution, $\beta^l \in$ Chi$(k=2, loc=0.2, \sigma=0.09)$')
  plt.hist(A_DF['beta_lock'], 30)
  plt.xlabel('Beta lock')
  plt.ylabel('Frecuency')
  plt.show()
  return plt

#-----------------------------------------------------------------------------
# BETA UNLOCK HISTOGRAM
#-----------------------------------------------------------------------------
def bun(A_DF,i):
  fig = plt.figure(figsize=(8,6), dpi=100)
  ax = fig.add_subplot()
  fig.subplots_adjust(top=0.9)
  fig.suptitle('Beta unlock, period %s' %i, fontsize=14, fontweight='bold')
  ax.set_title(r'Chi distribution, $\beta^u \in$ Chi$(k=2, loc=0, \sigma=0.6)$')
  plt.hist(A_DF['beta_unlock'], 30)
  plt.xlabel('Beta unlock')
  plt.ylabel('Frecuency')
  plt.show()
  return plt

#-----------------------------------------------------------------------------
# dissolve DELAY HISTOGRAM
#-----------------------------------------------------------------------------
def loti(A_DF,i):
  fig = plt.figure(figsize=(8,6), dpi=100)
  ax = fig.add_subplot()
  fig.subplots_adjust(top=0.9)
  fig.suptitle('Dissolve delay, period %s' %i, fontsize=14, fontweight='bold')
  ax.set_title(r'Truncated Half-normal distribution, $T^l \in$ Half-norm(min=12, max=48) months')
  plt.hist(A_DF['dissolve_delay'], bins=20)
  plt.xlabel('Months')
  plt.ylabel('Frecuency')
  plt.show()
  return plt

#-----------------------------------------------------------------------------
# PLOT ORDER BOOK DEPTH CHART
#-----------------------------------------------------------------------------
def order_book(buyers_DF, sellers_DF, i):
  fig = plt.figure(figsize=(8,6), dpi=100)
  plt.hist(buyers_DF['bid_price'], 30)
  plt.hist(sellers_DF['ask_price'], 30)
  plt.xlabel('Price (USDT cents)')
  plt.ylabel('Number of agents)')
  labels= ["Buy Price","Sell Price"]
  plt.legend(labels)
  plt.show
  return plt

#-----------------------------------------
# PLOT SUPPLY and DEMAND:
#-----------------------------------------
def plot_supply_demand(buyers_DF, sellers_DF, endowment, moderation, i):
  fig = plt.figure(figsize=(8,6), dpi=100)
  buyers_DF['cumulative_demand'][buyers_DF.loc[:,'cumulative_demand']==0] = np.nan
  x3 = buyers_DF['cumulative_demand']
  y3 = buyers_DF['bid_price']

  x4 = sellers_DF.loc[sellers_DF['status']=='trader','cumulative_supply']
  y4 = sellers_DF.loc[sellers_DF['status']=='trader','ask_price']
  if len(x4) == 0:
    sellers = pd.DataFrame(bidprice, columns=['bid_price'])
    sellers.columns = ['ask_price']
    sellers['cumulative_supply'] = endowment - moderation
    x4 = sellers['cumulative_supply']
    y4 = sellers['ask_price']

  plt.plot(x3,y3, linestyle="",marker="o")
  plt.plot(x4,y4, linestyle="",marker="o")
  plt.xscale("log")
  plt.legend(['Demand','Supply (Sellers + Endowment)'])
  plt.title(f'Supply and Demand, period={i}')
  plt.xlabel('Quantity')
  plt.ylabel('Price')
  plt.show()
  return plt

#-----------------------------------------
# PLOT LIQUID VS. STAKED tokens:
#-----------------------------------------
def plot_liquid_staked(liquid, total_staked, e):
  mot = np.arange(1,e+1)
  fig = plt.figure(figsize=(8,6), dpi=100)
  plt.plot(mot, total_staked,marker="o")
  plt.plot(mot, liquid,marker="o")
  plt.title('Liquid vs. Staked tokens')
  plt.xlabel('Month')
  plt.ylabel('TOK')
  plt.legend(['Total TOK Staked','Liquid TOK'])
  plt.show()
  return plt

#-----------------------------------------
# PLOT NUMBER OF AGENTS:
#-----------------------------------------
def plot_agents(n_buy,n_sell,n_desp,n_dissol, e):
  mot = np.arange(1,e+1)
  fig = plt.figure(figsize=(8,6), dpi=100)
  ax = fig.add_subplot(111)
  fig.subplots_adjust(top=0.9)
  fig.suptitle('$\gamma_t$=%s, $\gamma_m$=%s, $\gamma_b$=%s' %(rt, rm, rb), fontsize=14, fontweight='bold')

  line1 = ax.plot(mot, n_buy,'-r',marker="o",label='Buyers')

  ax2 = ax.twinx()
  line2 = ax2.plot(mot, n_sell,'-b',marker="o", label='Sellers', )
  line3 = ax2.plot(mot, n_desp,'-g',marker="o", label='Critical sellers')
  line4 = ax2.plot(mot, n_dissol,'-c',marker="o", label='Dissolvers')

  lns = line1+line2+line3+line4
  labs = [l.get_label() for l in lns]
  ax.legend(lns, labs, loc=0)

  ax.set_ylabel('Number of buyers')
  ax.set_xlabel('Month')
  ax2.set_ylabel('Number of sellers, critical sellers, dissolvers')

  plt.show()
  return plt

##################################################
## PLOT PRICE
##################################################
def plot_p(price,cost_usd,e):
  end = len(price)
  mot = np.arange(0,e+1)
  fig = plt.figure(figsize=(8,6), dpi=100)
  ax = fig.add_subplot(111)
  fig.subplots_adjust(top=0.9)
  fig.suptitle('$C_T$ = %s USD, $P_0 =$ %s USD, $\gamma_t$=%s, $\gamma_m$=%s, $\gamma_b$=%s' %(cost_usd, price[0]/100, rt, rm, rb), fontsize=14, fontweight='bold')
  plt.plot(mot, price[0:end],marker="o")
  #plt.title(r'Price, $P_0 =$ %s cents' %price[0])
  plt.xlabel('Month')
  plt.ylabel('Price [Cents]')
  plt.show()
  return plt
##################################################

##################################################
## PLOT VOLUME
##################################################
def plot_vol(volume,e):
  mot = np.arange(1,e+1)
  fig = plt.figure(figsize=(8,6), dpi=100)
  ax = fig.add_subplot(111)
  fig.subplots_adjust(top=0.9)
  fig.suptitle('$\gamma_t$=%s, $\gamma_m$=%s, $\gamma_b$=%s' %(rt, rm, rb), fontsize=14, fontweight='bold')
  plt.plot(mot, volume,marker="o")
  #plt.title('Volume Transacted')
  plt.xlabel('Month')
  plt.ylabel('Volume transacted [TOK]')
  plt.show()
  return plt
##################################################

##################################################
## PLOT STAKING REWARD
##################################################
def plot_r_s(staking_reward,e):
  mot = np.arange(1,e+1)
  fig = plt.figure(figsize=(8,6), dpi=100)
  ax = fig.add_subplot(111)
  fig.subplots_adjust(top=0.9)
  fig.suptitle('$\gamma_t$=%s, $\gamma_m$=%s, $\gamma_b$=%s' %(rt, rm, rb), fontsize=14, fontweight='bold')
  plt.plot(mot, staking_reward,marker="o")
  #plt.title('Annual percentage yield')
  plt.xlabel('Month')
  plt.ylabel('APY/100')
  plt.show()
  return plt
##################################################

##################################################
## PLOT TOTAL STAKED PER PERIOD
##################################################
def plot_Q_s(total_staked,e_stk, stakers_stake, seniors_stake, e):
  mot = np.arange(1,e+1)
  fig = plt.figure(figsize=(8,6), dpi=100)
  ax = fig.add_subplot(111)
  fig.subplots_adjust(top=0.9)
  fig.suptitle('$\gamma_t$=%s, $\gamma_m$=%s, $\gamma_b$=%s' %(rt, rm, rb), fontsize=14, fontweight='bold')
  plt.plot(mot, total_staked,marker="o")
  plt.plot(mot, e_stk,marker="o")
  plt.plot(mot, stakers_stake,marker="o")
  plt.plot(mot, seniors_stake,marker="o")
  plt.yscale("log")
  plt.xlabel('Month')
  plt.ylabel('Log(Cumulative MOD staked)')
  plt.legend(['Total Staked','Remaining endowment', 'Staked by stakers', 'Seniors stake'])
  plt.show()
  return plt
##################################################

##################################################
## PLOT NUMBER OF STAKERS
##################################################
def plot_n_stk(n_stakers,e):
  mot = np.arange(1,e+1)
  fig = plt.figure(figsize=(8,6), dpi=100)
  ax = fig.add_subplot(111)
  fig.subplots_adjust(top=0.9)
  fig.suptitle('$\gamma_t$=%s, $\gamma_m$=%s, $\gamma_b$=%s' %(rt, rm, rb), fontsize=14, fontweight='bold')
  plt.plot(mot, n_stakers,marker="o")
  #plt.title('New stakers in each month')
  plt.xlabel('Month')
  plt.ylabel('No. of new stakers')
  plt.show()
  return plt
##################################################

##################################################
## PLOT CUMULATIVE NUMBER OF STAKERS
##################################################
def plot_stakers(c_stakers,e):
  mot = np.arange(1,e+1)
  fig = plt.figure(figsize=(8,6), dpi=100)
  plt.plot(mot, c_stakers[0:e],marker="o")
  plt.title('Cumulative number of stakers')
  plt.xlabel('Month')
  plt.ylabel('Number')
  plt.show()
  return plt
##################################################

##################################################
## PLOT CUMULATIVE STAKED
##################################################
def plot_stk(c_stk_all,c_endow,c_stkrs, e):
  mot = np.arange(1,e+1)
  fig = plt.figure(figsize=(8,6), dpi=100)
  plt.plot(mot, c_stk_all[0:e], marker="o")
  plt.plot(mot, c_endow[0:e], marker="o")
  plt.plot(mot, c_stkrs[0:e], marker="o")
  plt.yscale("log")
  plt.title('Cumulative TOK staked')
  plt.xlabel('Month')
  plt.ylabel('Log(Cumulative TOK staked)')
  plt.legend(['Total cumulative staked','Cumulative remaining endowment', 'Cumulative stakers'])
  plt.show()
  return plt
##################################################

##################################################
## PLOT TOK burned, moderation, treasury
##################################################
def plot_split(burned,moderation,treasury, e):
  mot = np.arange(1,e+1)
  fig = plt.figure(figsize=(8,6), dpi=100)
  ax = fig.add_subplot(111)
  fig.subplots_adjust(top=0.9)
  fig.suptitle('$\gamma_t$=%s, $\gamma_m$=%s, $\gamma_b$=%s' %(rt, rm, rb), fontsize=14, fontweight='bold')
  plt.plot(mot, moderation,marker="o")
  plt.plot(mot, treasury,marker="o")
  plt.plot(mot, burned,marker="o")
  #plt.title('Total cost split into $Q^m$, $Q^t$, and  $Q^b$')
  plt.xlabel('Month')
  plt.ylabel('TOK')
  plt.legend(['Moderation Rewards ($Q^m$)','To Treasury $Q^t$ ', 'Burned $Q^b$'])
  plt.show()
  return plt
##################################################

##################################################
## PLOT TOK burned, moderation, treasury
##################################################
def plot_mean_rewards(msenior_rew, mjunior_rew, e):
  mot = np.arange(1,e+1)
  fig = plt.figure(figsize=(8,6), dpi=100)
  ax = fig.add_subplot(111)
  fig.subplots_adjust(top=0.9)
  fig.suptitle('$\gamma_t$=%s, $\gamma_m$=%s, $\gamma_b$=%s' %(rt, rm, rb), fontsize=14, fontweight='bold')
  plt.plot(mot, msenior_rew,marker="o")
  plt.plot(mot, mjunior_rew,marker="o")
  plt.title('Cumulative average rewards per moderator per task')
  plt.xlabel('Month')
  plt.ylabel('TOK')
  plt.legend(['Senior','Junior'])
  plt.show()
  return plt
##################################################

##################################################
## PLOT Nt in time
##################################################
def plot_number_tasks(number_tasks, multiplier, e):
  n_tasks = [item * multiplier for item in number_tasks]
  mot = np.arange(1,e+1)
  fig = plt.figure(figsize=(8,6), dpi=100)
  ax = fig.add_subplot(111)
  fig.subplots_adjust(top=0.9)
  fig.suptitle('$\gamma_t$=%s, $\gamma_m$=%s, $\gamma_b$=%s' %(rt, rm, rb), fontsize=14, fontweight='bold')
  plt.plot(mot, n_tasks,marker="o")
  #plt.title('Number of tasks per month')
  plt.xlabel('Month')
  plt.ylabel('Number of tasks')
  plt.show()
  return plt
##################################################

##################################################
## PLOT Burned/TotalSupply ratio
##################################################
def plot_ratioburned(burned, liquid, e):
  mot = np.arange(1,e+1)
  tot = 1e9
  new_tot = np.empty(len(mot))
  ratio = np.empty(len(mot))
  ratio_liquid = np.empty(len(mot))
  for i, vals in enumerate(burned):
    new_tot[i] = tot - vals
    tot = new_tot[i]
    ratio[i] = vals/new_tot[i]
    ratio_liquid[i] = vals/liquid[i]
  fig = plt.figure(figsize=(8,6), dpi=100)
  ax = fig.add_subplot(111)
  fig.subplots_adjust(top=0.9)
  fig.suptitle('$\gamma_t$=%s, $\gamma_m$=%s, $\gamma_b$=%s' %(rt, rm, rb), fontsize=14, fontweight='bold')
  plt.plot(mot, ratio,marker="o")
  plt.plot(mot, ratio_liquid,marker="o")
  plt.xlabel('Month')
  plt.ylabel('Ratio')
  plt.legend(['Burned/Tot supply ratio','Burned/Liquid ratio'])
  plt.show()
  return plt
##################################################

##################################################
## PLOT Staking/circulating ratio
##################################################
def plot_ratiostaked(liquid, total_staked, e):
  mot = np.arange(1,e+1)
  ratio = np.empty(len(mot))
  for i, vals in enumerate(total_staked):
    ratio[i] = vals/liquid[i]
  fig = plt.figure(figsize=(8,6), dpi=100)
  ax = fig.add_subplot(111)
  fig.subplots_adjust(top=0.9)
  fig.suptitle('$\gamma_t$=%s, $\gamma_m$=%s, $\gamma_b$=%s' %(rt, rm, rb), fontsize=14, fontweight='bold')
  plt.plot(mot, ratio,marker="o")
  #plt.title('Ratio of burned to total supply')
  plt.xlabel('Month')
  plt.ylabel('Staked-Liquid Ratio')
  plt.show()
  return plt, ratio
##################################################

##################################################
## PLOT burned and liquid tokens per period
##################################################
def plot_burnedliquid(burned, liquid,rt,rm,rb, e):
  mot = np.arange(1,e+1)
  fig = plt.figure(figsize=(8,6), dpi=100)
  ax = fig.add_subplot(111)
  fig.subplots_adjust(top=0.9)
  fig.suptitle('$\gamma_t$=%s, $\gamma_m$=%s, $\gamma_b$=%s' %(rt, rm, rb), fontsize=14, fontweight='bold')
  plt.plot(mot, burned, marker="o")
  plt.plot(mot, liquid,marker="o")
  plt.yscale("log")
  plt.xlabel('Month')
  plt.ylabel('TOK')
  plt.legend(['Burned','Liquid'])
  plt.show()
  return plt
##################################################

"""### Functions - Staking"""

################################################################################
# Calculate the annual staking reward using the monthly stake:
################################################################################
def annual_staking_reward(staking_pool, daily_reserve, treasury, idx_period):
  #sum_staked = staking_pool.loc[idx_period, 'sum_Q_all']
  cumsum_staked = staking_pool.loc[idx_period,'cumsum_Q_all']
  APY = (daily_reserve*365+ treasury)/cumsum_staked
  return APY
################################################################################

################################################################################
#  AGENTS' STATUS: TRADER, STAKER, OR DISSOLVER?
################################################################################
def agent_status(sellers_DF, staking_pool, daily_reserve, seniors_staked,treasury, idx_period):
  APY_prev = staking_pool.loc[idx_period-1, 'annual_staking_reward']
  b_unlock = sellers_DF['beta_unlock']
  diss_del = sellers_DF['dissolve_delay']
  # Who is trader, staker and dissolver?
  for i, vals in enumerate(sellers_DF['beta_lock']):
    if (sellers_DF.loc[i, 'status'] == 'trader') and (vals < APY_prev):
      #print('We have a staker in tha house!')
      #print("Alpha lock for this agent is: ", vals)
      sellers_DF.loc[i, 'status'] = 'staker'
      sellers_DF.loc[i, 'Q_s'] = sellers_DF.loc[i, 'Q_TOK']
      sellers_DF.loc[i, 'Q_TOK'] = 0
      #print("Unlocking product: ", vals*b_unlock[i])
      #print("Previous staking reward: ", rs_prev)
    elif (sellers_DF.loc[i, 'status'] == 'staker') and (vals*b_unlock[i] > APY_prev):
      print('We have a dissolver in tha house!')
      sellers_DF.loc[i, 'status'] = 'dissolver'
      #unlock[i] = vals*b_unlock[i]
    elif (sellers_DF.loc[i, 'status'] == 'dissolver') and (idx_period == diss_del[i] + 1):
      #print('A dissolver gets their money back')
      sellers_DF.loc[i, 'status'] = 'trader'
      sellers_DF.loc[i, 'Q_TOK'] = sellers_DF.loc[i, 'Q_s']
      sellers_DF.loc[i, 'Q_s'] = 0

  for i, vals in enumerate(sellers_DF['beta_lock']):
    if (sellers_DF.loc[i, 'status'] == 'staker'):
      unlock = vals*b_unlock[i]
      if unlock > APY_prev:
        sellers_DF.loc[i, 'status'] = 'dissolver'
    elif (sellers_DF.loc[i, 'status'] == 'dissolver'):
      if idx_period == diss_del[i] + 1:
        print('A dissolver gets their money back')
        sellers_DF.loc[i, 'status'] = 'trader'
        sellers_DF.loc[i, 'Q_TOK'] = sellers_DF.loc[i, 'Q_s']
        sellers_DF.loc[i, 'Q_s'] = 0

      #print('This is a staker with unlock product equal to: ', unlock)
      #print("Previous staking reward: ", rs_prev)

  # Update staking pool:
  sum_Qs = sellers_DF.loc[sellers_DF['status'] == 'staker', 'Q_s'].sum()
  stakers = sellers_DF.loc[sellers_DF['status'] == 'staker']
  n_stake = len(stakers)
  staking_pool.loc[idx_period, 'seniors_stake'] = seniors_staked
  staking_pool.loc[idx_period, 'sum_Q_s'] = sum_Qs
  staking_pool.loc[idx_period, 'sum_Q_all']= staking_pool.loc[idx_period, 'rem_endow'] + sum_Qs
  rendow = staking_pool.loc[idx_period, 'rem_endow']
  #previous_Q_all = staking_pool.loc[idx_period-1, 'sum_Q_all']

  #staking_pool.loc[idx_period, 'cumsum_Q_all'] = staking_pool.loc[idx_period, 'sum_Q_all'] + staking_pool.loc[idx_period-1, 'cumsum_Q_all']
  staking_pool.loc[idx_period, 'cumsum_Q_all'] = staking_pool.loc[idx_period, 'sum_Q_all'] + staking_pool.loc[idx_period-1, 'cumsum_Q_s'] + seniors_staked
  #staking_pool.loc[idx_period, 'cumsum_rem_endow'] = rendow + staking_pool.loc[idx_period-1, 'cumsum_rem_endow']
  staking_pool.loc[idx_period, 'cumsum_Q_s'] = sum_Qs + staking_pool.loc[idx_period-1, 'cumsum_Q_s']
  APY_now = annual_staking_reward(staking_pool, daily_reserve, treasury, idx_period)
  staking_pool.loc[idx_period, 'annual_staking_reward'] = APY_now
  staking_pool.loc[idx_period, 'number_stakers'] = n_stake
  # Update rewards for stakers:
  #sellers_DF = sellers_DF.loc[sellers_DF['status'] == 'trader']
  return sellers_DF, staking_pool, APY_prev
################################################################################

"""### Functions - Moderation process


*   Generate moderators pool
*   Select moderators from pool for each TASK
*   Evaluation and reward distribution
*   Simulate task


"""

#############################################################################
## GENERATE MODERATORS POOL
#############################################################################
mu1, sigma1 ,N1 = 35, 5, int(user_pool_number * senior_percentage)
mu2, sigma2 ,N2 = 75, 5, (user_pool_number - N1)
X1 = np.random.normal(mu1, sigma1, N1)
X2 = np.random.normal(mu2, sigma2, N2)
X = np.concatenate([X1, X2])
# print(X)
for i in range (user_pool_number):
  X[i] = round(X[i],1)
reputation_score = X
# print (X)

level = np.zeros((user_pool_number,), dtype = object)

for i in range(user_pool_number):
  level[i] = 'junior'

for i in range(user_pool_number):
  if X[i] >= 50:
    level[i] = 'senior'
# print (level)
# 0 represents junior, 1 represents senior
initial_moderator_frame = pd.DataFrame (reputation_score)
initial_moderator_frame.insert(initial_moderator_frame.shape[1], 'Level', level)
initial_moderator_frame.index.name = 'index'
initial_moderator_frame['Moderator #'] = initial_moderator_frame.index
initial_moderator_frame.columns = ['Reputation_Score','Level','Moderator #']
# initial_moderator_frame.index.name = 'Moderator #'
# initial_moderator_frame['Moderator #'] = initial_moderator_frame.index

#Compute TOK staked or locked
test_times = np.zeros((user_pool_number,), dtype = int)
TOK_staked = np.zeros((user_pool_number,), dtype = int)
TOK_locked = np.zeros((user_pool_number,), dtype = int)

dimension = int(user_pool_number * senior_percentage)
TOK_reward = np.zeros((dimension,), dtype = int)
TOK_reward_junior = np.zeros((dimension,), dtype = int)

qualif = []
delt= []
#staked
for i in range (user_pool_number):
  if level[i] == 'senior':
    TOKstaked = aS * (reputation_score[i])**eta + abs(random.normalvariate(mu=0, sigma=1500))
    #TOKstaked = aS * (reputation_score[i]) + abs(random.normalvariate(mu=0, sigma=1500))
    temp1 = abs(random.normalvariate(mu=0, sigma=1500))
    delt.append(temp1)
    temp = aS * (reputation_score[i])**eta
    qualif.append(temp)
    TOK_staked[i] = TOKstaked

#locked
for i in range (user_pool_number):
  if level[i] == 'junior':
    TOKlocked = aL * (reputation_score[i] - 20) + abs(random.normalvariate(mu = (reputation_score[i] - 20) , sigma=1))
    TOK_locked[i] = TOKlocked / 2
    TOK_reward_junior[i] = TOKlocked / 2
new_rew = np.concatenate((TOK_reward_junior, TOK_reward))

initial_moderator_frame.insert(initial_moderator_frame.shape[1], 'test_times', test_times)
initial_moderator_frame.insert(initial_moderator_frame.shape[1], 'TOK_staked', TOK_staked)
initial_moderator_frame.insert(initial_moderator_frame.shape[1], 'TOK_locked', TOK_locked)
initial_moderator_frame.insert(initial_moderator_frame.shape[1], 'TOK_reward', new_rew)

#############################################################################

#############################################################################
## SELECT MODERATORS FROM POOL FOR EACH TASK
## TYPE()()
#############################################################################
def generate_moderators ():
  Nm = random.randint(3,9)
  while Nm % 2 != 1 :
    Nm = random.randint(3,9)
  # print (Nm)
  task_moderator = pd.DataFrame(columns=['Reputation_Score', 'Moderator #','Level', 'test_times','TOK_staked', 'TOK_locked'])
  for i in range (Nm):
    index = random.randint(0,599)
    #print(moderator_frame.loc[index])
    initial_moderator_frame['test_times'].loc[index] += 1
    task_moderator.loc[i] = initial_moderator_frame.loc[index]
  return task_moderator, Nm
#############################################################################

#############################################################################
## EVALUATION AND REWARD DISTRIBUTION
#############################################################################
def evaluation(task_moderator, moderator_frame, Nm, Cs, rm, rt, rb, aS, eta, multiplier, track_liquid, previous_price):
  performance = np.zeros((Nm,), dtype = int)
  correct_count = 0

  while correct_count <= Nm/2: # Making sure that more than half people are correct
    performance = np.zeros((Nm,), dtype = int)

    for i in range (Nm):
      if task_moderator['Level'].loc[i] == 'senior':
        num = random.randint(1,100)
        if num > 1: # 99% correctness
          performance[i] = 1
      if task_moderator['Level'].loc[i] == 'junior':
        num = random.randint(1,100)
        if num > 10: # 90% correctness
          performance[i] = 1

    correct_count = sum(performance)

  #print(performance)

  task_moderator.insert(task_moderator.shape[1], 'Correct', performance)

  #add test times
  # for i in range (Nm):
  #   task_moderator['test_times'].loc[i] += 1


  #Calculate reward
  reward = np.zeros((Nm,), dtype = float)
  total_correct_reputation = 0
  #Ct = Nm*Cs*multiplier   # --> when task cost is fixed in $TOK
  Ct = (task_cents/previous_price)*multiplier # --> when task cost is fixed in USD
  Qm = rm*Ct
  Qt = rt*Ct
  Qb = rb*Ct

  for i in range (Nm):
    if performance[i] == 1 :
      total_correct_reputation += math.floor(task_moderator['Reputation_Score'].loc[i])

  for i in range (Nm):
    if performance[i] == 1 :
      reward_i = (task_moderator['Reputation_Score'].loc[i] / total_correct_reputation) * Qm
      reward[i] = reward_i

  for i in range (Nm):
    reward[i] = round(reward[i],1)

  task_moderator.insert(task_moderator.shape[1], 'TOK_Reward', reward)


  #update reputation_score and new staked amount for seniors
  for i in range (Nm):
    if task_moderator['Correct'].loc[i] == 1:
      task_moderator['Reputation_Score'].loc[i] += 0.1
      # New reputation score:
      newRS = task_moderator['Reputation_Score'].loc[i]
      # Moderator # :
      id_moderator = task_moderator['Moderator #'].loc[i]
      # Updating moderator frame to add accumulated rewards:
      if task_moderator['Level'].loc[i]=='junior':
        moderator_frame['TOK_locked'].loc[id_moderator] += reward[i]/2
        moderator_frame['TOK_reward'].loc[id_moderator] += reward[i]/2
        track_liquid += reward[i]/2
      else:
        moderator_frame['TOK_reward'].loc[id_moderator] += reward[i]
        track_liquid += reward[i]
      # Determine if staked amount needs to increase:
      r_newRS = round(newRS, 1)
      f_newRS = math.floor(r_newRS)
      if newRS > 50.0 and r_newRS/f_newRS == 1.0:
        #print(r'Senior %s just got promoted and needs to stake more' %id_moderator)
        moderator_frame['TOK_staked'].loc[i] = aS*(newRS**eta) + abs(random.normalvariate(mu=0, sigma=1500))
    else:
      task_moderator['Reputation_Score'].loc[i] -= 0.1

  new_moderator_frame = moderator_frame
  task_moderator1 = task_moderator
  new_track_liquid = track_liquid

  return task_moderator1, new_moderator_frame, Ct, Qm, Qt, Qb, new_track_liquid
#############################################################################

#############################################################################
## TASK SIMULATION
## TYPE()()
#############################################################################

def simulate_task (count, moderator_frame, cost, track_liquid, previous_price):
  task_moderator, Nm = generate_moderators ()
  task_moderator_evaluated, new_moderator_frame, Ct, Qm, Qt, Qb, new_track_liquid = evaluation(task_moderator, moderator_frame, Nm, Cs, rm, rt, rb, aS, eta, multiplier, track_liquid, previous_price)
  cost.append(Ct)

  task_index = np.zeros((Nm,), dtype = float)
  for i in range (Nm):
    task_index[i] = count
  task_moderator_evaluated.insert(task_moderator_evaluated.shape[1], 'task #', task_index)

  return task_moderator_evaluated, new_moderator_frame, cost, new_track_liquid
#############################################################################

#############################################################################
## ITERATION OF Nt TASKS
## TYPE()()
#############################################################################

def verification_work(Nt_min, Nt_max, Nt_steps, moderator_frame, track_liquid, previous_price):
  Nt = random.randrange(Nt_min, Nt_max, Nt_steps)
  cost = []
  beginning_frame, new_moderator_frame, cost, new_track_liquid = simulate_task (0, moderator_frame, cost, track_liquid, previous_price)
  count = 0
  track_liquid = new_track_liquid
  for i in range (1, Nt):
    count += 1
    task_new, new_moderator_frame, cost, new_track_liquid = simulate_task (count, new_moderator_frame, cost, track_liquid, previous_price)
    beginning_frame = pd.concat([beginning_frame,task_new], ignore_index = True)
    for i in range(beginning_frame.shape[0]):
      beginning_frame['Reputation_Score'].loc[i] = round(beginning_frame['Reputation_Score'].loc[i],2)
  beginning_frame = beginning_frame[['task #','Moderator #','Reputation_Score','Level','test_times','TOK_staked','TOK_locked','Correct','TOK_Reward']]
  TOKcost = sum(cost)

  return beginning_frame, new_moderator_frame, TOKcost, Nt, new_track_liquid
#############################################################################
#print('Total submission cost (TOK): ', TOKcost)
#print('Total verification rewards (TOK): ', TOKrew)
#print('What goes to treasury (TOK): ', TOK_treasury)
#print('Amount of TOK burned in this period: ', TOKbur)
#print('Total TOK staked: ', seniors_total_staked)

"""## 3. Month 1 - Only buyers and ITE

### Determine $P_1$
"""

############################################################################
# Period 1
############################################################################
## (0) Run moderation process:
track_liquid = 0
beginning_frame, new_moderator_frame, m1_cost, Nt, new_track_liquid = verification_work(Nt_min, Nt_max, Nt_steps, initial_moderator_frame, track_liquid, price[0])
liquid_in_period.append(new_track_liquid)
sum_senior_rewards = new_moderator_frame.loc[new_moderator_frame['Level'] == 'senior', 'TOK_reward'].sum()
senior_reward.append(sum_senior_rewards)
mean_senior_rewards = new_moderator_frame.loc[new_moderator_frame['Level'] == 'senior', 'TOK_reward'].mean()
mean_junior_rewards = new_moderator_frame.loc[new_moderator_frame['Level'] == 'junior', 'TOK_reward'].mean()
msenior_rew.append(mean_senior_rewards)
mjunior_rew.append(mean_junior_rewards)
number_tasks.append(Nt)
mode_cost.append(m1_cost)
treasury.append(rt*m1_cost)
burned.append(rb*m1_cost)
rewards.append(rm*m1_cost)
seniors_staked.append(new_moderator_frame['TOK_staked'].sum())
mode_liquid.append(new_moderator_frame['TOK_reward'].sum())
junior_locked = new_moderator_frame['TOK_locked'].sum()
#display(new_moderator_frame)

print('Total submission cost (TOK) in month 1: ', mode_cost[0])
print('TOK liquid in month 1: ', mode_liquid[0])
print('What goes to treasury (TOK) in month 1: ', treasury[0])
print('Amount of TOK burned in month 1: ', burned[0])
print('Total TOK staked in month 1: ', seniors_staked[0])

# Amount of TOK token taken from the ITE:
moderation_tokens = m1_cost + seniors_staked[0] - liquid_in_period[0] +junior_locked + burned[0]
#moderation_tokens = seniors_staked[0] + junior_locked + burned[0]
print('Moderation tokens: ', moderation_tokens)
#-------------------------------------------------------
## (1) Generate agents:
buyers = generate_buyers(nb_mean, price, 0, QU_mean, QU_sd, alpha_loc,
                    alpha_scale, TC_df,TC_loc, TC_scale, bl_df, bl_loc,bl_scale,
                    bu_df, bu_loc, bu_scale, TL_loc, TL_scale)
#-------------------------------------------------------
# (2) Sellers:
bidprice = buyers['bid_price']
sellers = pd.DataFrame(bidprice, columns=['bid_price'])
sellers.columns = ['ask_price']
sellers["Q_TOK"]= endowment[0]
sellers['status'] = 'trader'
#-------------------------------------------------------
## (3) calculate cumulative demand
USDT = buyers['Q_USDT']
buyers['QB_TOK'] = USDT/bidprice
sum_usdt = np.cumsum(buyers['Q_USDT'])
demand = sum_usdt/buyers['bid_price']
buyers['cumulative_demand'] = demand
bidprice = buyers['bid_price']
#-------------------------------------------------------
## (4) calculate cumulative supply
sellers['cumulative_supply'] = endowment[0] - moderation_tokens
liquid.append(endowment[0])
print('Sellers: ',len(sellers))
print('Buyers: ',len(buyers))

#-------------------------------------------------------
## (5) find equilibrium price (intersection supply and demand)
[equilibrium_price, buyer_idx, seller_idx, eq_supply, eq_demand] = eq_price(buyers, sellers)

print(f"Buyer {buyer_idx+1} was the last to deal")
print(f"The overhang was {eq_demand - eq_supply}, equilibrium price in this period is {equilibrium_price}")
#print(f"and last sell price was {price_supply}")
print(f"Cumulative demand is {round(eq_demand,2)} TOK")
print(f"and Cumulative supply is {round(eq_supply, 2)} TOK.")

#---------------------------------
# (6) Save Results and Update Agents
#---------------------------------
nsell = 0
de = 0
price.append(equilibrium_price)
volume.append(eq_demand)
number_buyers.append(buyer_idx+1)
number_sellers.append(nsell)
desp_sellers.append(de)
## Update agents (buyers become sellers)
pot_two_sellers = generate_sellers(buyer_idx,price, 1, buyers)
## Generate new buyers
pot_two_buyers = generate_buyers(nb_mean, price, 1, QU_mean, QU_sd, alpha_loc,
                                 alpha_scale, TC_df,TC_loc, TC_scale, bl_df,
                                 bl_loc,bl_scale, bu_df, bu_loc, bu_scale, TL_loc,
                                 TL_scale)
## Update lists and siplay tables
L_buyers.append(pot_two_buyers) # in position 0 of the L_buyers list
print('L_sellers')
display(L_sellers)
print("pot_two_sellers")
display(pot_two_sellers)
L_sellers.append(pot_two_sellers) # in position 0 of the L_sellers list
print('L_sellers new')
display(L_sellers)
display(buyers)
#alo(buyers,1)
#bun(buyers,1)
#loti(buyers,1)
#display(one_sellers)
############################################################################

print(price)

#display(L_sellers[0])

"""### Staking - first part
1.  Add staking columns to sellers
2.  Create Staking Pool dataframe
3.  Calculate staking reward for first period and add to staking pool
"""

################################################################################
# Update pot_two_sellers: add Q_staked, Q_reward, sum_Q_reward
################################################################################
#pot_two_sellers['Q_s']=0
#pot_two_sellers['Q_r']=0
#pot_two_sellers['sum_Q_r']=0
#pot_two_sellers['status']='trader'
################################################################################
# Create Staking Pool dataframe:
################################################################################
#bn=1e9
#remaining_endow = np.concatenate(([res_13[0]], res_13))
#staking_pool = pd.DataFrame(remaining_endow, columns=['rem_endow'])
staking_pool = pd.DataFrame(res_13, columns=['rem_endow'])
staking_pool.loc[36:47,'rem_endow'] = 0
staking_pool['seniors_stake'] = 0
staking_pool['sum_Q_s'] = 0 # sum of TOK staked by stakers
staking_pool['sum_Q_all']= 0   # Sum of all TOK staked (endowment + stakers)
staking_pool['number_stakers']=0  # number of stakers
#staking_pool['cumsum_rem_endow'] = 0
staking_pool['cumsum_Q_s'] = 0
staking_pool['cumsum_Q_all'] = seniors_staked[0]
staking_pool['annual_staking_reward'] = 0  # staking reward
staking_pool.loc[0, 'sum_Q_all'] = res_13[0]
#staking_pool.loc[0, 'cumsum_rem_endow'] = res_13[0]
staking_pool.loc[0, 'cumsum_Q_s'] = 0
staking_pool.loc[0,'cumsum_Q_all'] = res_13[0] + seniors_staked[0]
staking_pool.loc[0, 'seniors_stake'] = seniors_staked[0]

APY = annual_staking_reward(staking_pool, daily_reserve,treasury[0], 0) # this is an annual percentage
staking_pool.loc[0, 'annual_staking_reward'] = APY
display(staking_pool)
#######################################################
# Period 1
stk_r.append(APY)
total_staked.append(res_13[0])
n_stakers.append(0)
e_stk.append(res_13[0])
stakers_stake.append(0)

"""### Plots"""

############################################################################
# PLOTS for Period 1
############################################################################
#plot_alpha(buyers,1)
###plot_alpha(pot_two_sellers,1)
#price_distribution(buyers,1, price)
#plot_usdt(buyers,1)
#critical_time(pot_two_sellers,1)
##order_book(buyers, sellers, 1)
##sellers['status'] = 'trader'
#plot_supply_demand(buyers, sellers,endowment[0], moderation_tokens, 1)

"""## 4. Month 2 to END - MAIN LOOP"""

#############################################################################
# MAIN SIMULATION LOOP
## DETERMINE PRICE, FIND SPLIT AGENTS, AND UPDATE
#############################################################################
ns = len(pot_two_sellers)
dissolvers = []
dissolvers.append(0)

#=================================================
for j in period:
  print('We are in month: ', j)
  #--------------------------------------------
  # (1) Run moderation process:
  #--------------------------------------------
  track_liquid = 0
  beginning_frame, new_moderator_frame, TOKcost, Nt, new_track_liquid = verification_work(Nt_min, Nt_max, Nt_steps, initial_moderator_frame, track_liquid, price[j-1])
  liquid_in_period.append(new_track_liquid)
  sum_senior_rewards = new_moderator_frame.loc[new_moderator_frame['Level'] == 'senior', 'TOK_reward'].sum()
  senior_reward.append(sum_senior_rewards)
  mean_senior_rewards = new_moderator_frame.loc[new_moderator_frame['Level'] == 'senior', 'TOK_reward'].mean()
  mean_junior_rewards = new_moderator_frame.loc[new_moderator_frame['Level'] == 'junior', 'TOK_reward'].mean()
  msenior_rew.append(mean_senior_rewards)
  mjunior_rew.append(mean_junior_rewards)
  number_tasks.append(Nt)
  mode_cost.append(TOKcost)
  treasury.append(rt*TOKcost)
  burned.append(rb*TOKcost)
  rewards.append(rm*TOKcost)
  seniors_staked.append(new_moderator_frame['TOK_staked'].sum())
  mode_liquid.append(new_moderator_frame['TOK_reward'].sum())
  mode_locked = new_moderator_frame['TOK_locked'].sum()
  print('Total submission cost (TOK): ', mode_cost[j-1])
  print('TOK liquid = Total verification rewards (TOK): ', mode_liquid[j-1])
  print('What goes to treasury (TOK): ', treasury[j-1])
  print('Amount of TOK burned in this period: ', burned[j-1])
  print('Total TOK staked: ', seniors_staked[j-1])
  #moderation = burned[j-1] + seniors_staked[j-1] + mode_locked - mode_liquid[j-1]
  #moderation = TOKcost - liquid_in_period[j-1]
  moderation = burned[j-1]
  #old_liquid = m1_liquid #(take from day one)
  #old_staked = m1_staked #(ipso)
  #total_liquid = sum(new_mod_frame['TOK_rewards'])
  #total_staked = sum(new_mod_frame['TOK_staked'])
  #delta_liquid = new_liquid - old_liquid =
  #delta_staked = new_staked - old_staked
  #market.update(delta_liquid, delta_staked) (run simulation with updated macroeco parameters)
  #--------------------------------------------
  # (2) Call potential buyers and sellers:
  #--------------------------------------------
  buyers_DF = L_buyers[j-2]
  sellers_DF = L_sellers[j-2]
  #--------------------------------------------
  # (3) Staking:
  [sellers_DF, staking_pool, APY_prev] = agent_status(sellers_DF, staking_pool, daily_reserve, seniors_staked[j-1], treasury[j-1], j-1)
  #stakers = sellers_DF.loc(sellers_DF['status'] == 'staker')
    #print('Unlocking product: ', unlock)
  #print('Alpha lock: ', alock)
  #display(sellers_DF)
  #display(staking_pool)
  numstk = staking_pool.loc[j-1,'number_stakers']
  #total_staked.append(staking_pool.loc[j-1,'sum_Q_all'])
  total_staked.append(staking_pool.loc[j-1,'cumsum_Q_all'])
  e_stk.append(staking_pool.loc[j-1,'rem_endow'])
  stakers_stake.append(staking_pool.loc[j-1,'cumsum_Q_s'])
  stk_r.append(staking_pool.loc[j-1,'annual_staking_reward'])
  n_stakers.append(staking_pool.loc[j-1,'number_stakers'])
  diss = sellers_DF.loc[sellers_DF['status']=='dissolver']
  dissolvers.append(len(diss))
  # Print number of buyers, sellers, stakers, dissolvers:
  print('Number of potential sellers: ', len(sellers_DF))
  print('Number of potential buyers: ', len(buyers_DF))
  print('Number of stakers: ', numstk)
  print('Number of dissolvers: ', len(diss))

  # (2.1) Plot staking reward and unlock condition:
  #plt.plot(unlock, linestyle='', marker='o')
  #plt.axhline(y=rs_prev, color='r', linestyle='-')
  #plt.xlabel('Agent')
  #plt.ylabel('Beta unlock')
  #plt.show
  #display(sellers_DF)
  #----------------------------------
  # (4) Plot alphas and order book
  #----------------------------------
  #plot_alpha(buyers_DF,j)
  #plot_alpha(sellers_DF,j)
  #plot_usdt(buyers_DF,j)
  #plot_TOK(sellers_DF,j)
  #alo(sellers_DF, j)
  #bun(sellers_DF,j)
  #loti(sellers_DF,j)
  #critical_time(sellers_DF,j)
  #price_distribution(buyers_DF, j, price)
  #price_distribution(sellers_DF, j, price)
  #order_book(buyers_DF, sellers_DF,j)
  #----------------------------------
  # (5) Calculate Supply and Demand:
  #---------------------------------
  [sellers_DF, sum_desp] = desperate_sellers(sellers_DF, j) # includes now desperate
  nb=len(buyers_DF)
  ns=len(sellers_DF)
  desperates = sellers_DF.loc[sellers_DF['status'] == 'desperate']
  ndesp = len(desperates)
  desp_sellers.append(ndesp)
  #print('Second try, Desperate sellers: ', desperates)
  [buyers_DF, sellers_DF, sellers_supply] = cumulative_sd(nb, ns, buyers_DF,
                                          sellers_DF, sum_desp, endowment[j-1], moderation)
  traders = sellers_DF.loc[sellers_DF['status']=='trader']
  if len(traders)==0:
    liquid.append(sellers_DF['cumulative_supply'][sellers_DF.index[-1]]+liquid_in_period[j-1])
  else:
    liquid.append(traders['cumulative_supply'][traders.index[-1]]+liquid_in_period[j-1])
  plot_supply_demand(buyers_DF, sellers_DF,endowment[j-1], moderation, j)
  #-------------------------------------
  # (6) Determine price and split agent
  #     using the "Zig-zag" method:
  #-------------------------------------
  #[equilibrium_price, buyer_idx, seller_idx, eq_supply, eq_demand] = eq_price(buyers, sellers)
  buy = pd.DataFrame()
  sell = pd.DataFrame()
  buy['price'] = buyers_DF['bid_price']
  buy['qty_buyers'] = buyers_DF['QB_TOK']
  buy['cum_qty_buyers'] = buyers_DF['cumulative_demand']
  sell['price'] = sellers_DF['ask_price']
  sell['qty_sellers'] = sellers_DF['Q_TOK']
  sell['cum_qty_sellers'] = sellers_DF['cumulative_supply']
  market=pd.merge(buy.sort_values("price", ascending=True).reset_index(drop=True),
                sell, on="price", how ="outer", suffixes=
                ("_buyers", "_sellers")).sort_values("price").fillna(method="ffill").reset_index(drop=True)
  equilibrium_idx = abs(np.sign(market.cum_qty_buyers - market.cum_qty_sellers).diff()).argmax()
  #equilibrium_price = market.loc[equilibrium_idx-1:equilibrium_idx+1,"price"].mean()
  equilibrium_price = market.loc[equilibrium_idx,"price"]
  eq_supply = market.loc[equilibrium_idx, 'cum_qty_sellers']
  eq_demand = market.loc[equilibrium_idx, 'cum_qty_buyers']
  split_demand = market.loc[equilibrium_idx-1, 'cum_qty_buyers']
  bidx = buyers_DF.index[buyers_DF['cumulative_demand'] == split_demand].tolist()
  sidx = sellers_DF.index[sellers_DF['cumulative_supply'] == eq_supply].tolist()
  buyer_idx = bidx[0]
  seller_idx = sidx[0]
  #------------------------------
  # (7) Update price and volume:
  #------------------------------
  price.append(round(equilibrium_price,2))
  volume.append(eq_supply)
  #---------------------------------------------------------------------------
  # (8) Update agents:
  #---------------------------------------------------------------------------
  # Update SELLERS:
  rem_usdt = buyers_DF.loc[buyer_idx,'Q_USDT'] - (eq_demand-eq_supply)*equilibrium_price
  print(f"Buyer {buyer_idx+1} and Seller {seller_idx} were the last to deal")
  print(f"The overhang was {eq_demand - eq_supply}, the equilibrium price is {round(equilibrium_price, 2)} cents")
  print(f"Cumulative demand is {eq_demand}")
  print(f"and Cumulative supply is {eq_supply}.")
  print(f"Buyer {buyer_idx} has to be split.")
  print(f"Split buyer new balance in USDT is: {rem_usdt}.")
  next_sellers = update_sellers(price,j,buyer_idx, seller_idx,
                                               buyers_DF,sellers_DF, rem_usdt)
  number_buyers.append(buyer_idx+1)
  number_sellers.append(seller_idx+1)
  # Generate NEW BUYERS:
  new_buyers = generate_buyers(nb_mean, price, j, QU_mean, QU_sd, alpha_loc,
                    alpha_scale, TC_df,TC_loc, TC_scale, bl_df, bl_loc,bl_scale,
                    bu_df, bu_loc, bu_scale, TL_loc, TL_scale)
  #----------------------------------------------------------------------------
  #display(next_sellers)
  # (9) Update agent's list:
  L_buyers.append(new_buyers)
  L_sellers.append(next_sellers)
  # END OF LOOP
  #=================================================

#-------------------------------------------------------------------------------
# Cumulative stakers and staked TOK
c_stakers = np.cumsum(staking_pool['number_stakers'])
c_stk_all = np.cumsum(staking_pool['cumsum_Q_all'])
c_endow = np.cumsum(staking_pool['rem_endow'])
c_stkrs = np.cumsum(staking_pool['cumsum_Q_s'])
#-------------------------------------------------------------------------------

################################################################################

################################################################################

"""## 5. Results"""

# Plots
plot_p(price, task_usd_dollars, epoch)
plot_vol(volume, epoch)
plot_agents(number_buyers, number_sellers, desp_sellers, dissolvers, epoch)
plot_r_s(stk_r, epoch)
plot_Q_s(total_staked,e_stk, stakers_stake, seniors_staked, epoch)
plot_n_stk(n_stakers, epoch)
plot_stakers(c_stakers, epoch)
plot_stk(c_stk_all,c_endow,c_stkrs, epoch)
plot_liquid_staked(liquid, total_staked, epoch)
plot_split(burned,rewards, treasury, epoch)
plot_mean_rewards(msenior_rew, mjunior_rew, epoch)
plot_number_tasks(number_tasks,multiplier, epoch)
plot_ratioburned(burned, liquid, epoch)
plot_ratiostaked(liquid, total_staked, epoch)
#plot_burnedliquid(burned, liquid, epoch)

from tempfile import TemporaryFile
outfile_3 = TemporaryFile()

np.savez('/content/sample_data/outfile_3', price=price, liquid=liquid, burned=burned, treasury=treasury, rewards=rewards, apy=stk_r, seniors_staked=seniors_staked, senior_reward=senior_reward)

from google.colab import drive
drive.mount('/content/drive')

print("--- %s seconds ---" % (time.time() - start_time))
