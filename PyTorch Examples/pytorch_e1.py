# -*- coding: utf-8 -*-
"""PyTorch_E1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bPR7Jj3ULUjYzrjy6JTG6JVQS07hDhTe
"""

#---------------------------------------------------------------------------
# Pytorch Exercises Vol. I - Linear Regression
# @author: Diana Gamborino 20.09.2023
#---------------------------------------------------------------------------

# Commented out IPython magic to ensure Python compatibility.
# %reset
import torch
import torch.nn as nn
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

#--------------------------------------------
# Moore's Law
#--------------------------------------------
# Get the data
!wget -nc https://raw.githubusercontent.com/lazyprogrammer/machine_learning_examples/master/tf2.0/moore.csv
#from google.colab import files
#uploaded = files.upload()

# Load in the data
data = pd.read_csv('moore.csv', header=None).values
X = data[:,0].reshape(-1,1) # Make it a 2D array of size NxD where D=1 (dimension)
Y = data[:,1].reshape(-1,1)

# Plot data
plt.scatter(X,Y);

# Need to linearize to apply linear model
Y = np.log(Y)
plt.scatter(X,Y);

# Normalize data (aka standardize data)
mx = X.mean()
sx = X.std()
my = Y.mean()
sy = Y.std()
X = (X - mx)/sx
Y = (Y - my)/sy

# Plot - data is centered and in a small range
plt.scatter(X,Y);

# Cast to float32 (PyTorch uses float32 by default, Numpy creates float64 by default)
X = X.astype(np.float32)
Y = Y.astype(np.float32)
# Need to convert X and Y to Troch tensors:
inputs = torch.from_numpy(X)
targets = torch.from_numpy(Y)

# Create linear regression model
model = nn.Linear(1,1)
# Loss and optimizer
criterion = nn.MSELoss()
optimizer = torch.optim.SGD(model.parameters(), lr=0.01, momentum= 0.7)

#-----------------------
# Train the model
#-----------------------
n_epochs = 100
losses = []
for it in range(n_epochs):
  # zero the parameter gradients
  optimizer.zero_grad()
  #Forward pass
  outputs = model(inputs)
  loss = criterion(outputs, targets)
  # Save the loss
  losses.append(loss.item())
  # Backward and optimize
  loss.backward()
  optimizer.step()

  print(f'Epoch {it+1}/|{n_epochs}, Loss: {loss.item():4f}')
#------------------------

# Loss per iteration
plt.plot(losses);
# Plot graph of results
predicted = model(inputs).detach().numpy()
plt.plot(X,Y,'ro', label='Original data')
plt.plot(X, predicted, label='Fitted line')
plt.legend()
plt.show()

# Check performance
w = model.weight.data.numpy()
print(w)

# END